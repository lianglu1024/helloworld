# 代理模式

代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问。简而言之，**代理对象=增强代码+目标对象**



![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh6tdqf3lpj30b4067aaa.jpg)

* RealSubject（目标对象）：真实的业务逻辑类。比如房东，它的action是租房
* Subject：定义代理类和RealSubject的公共对外方法。比如租房
* Proxy：代理类，帮助RealSubject去完成action，同时还能增强action

## 静态代理类

首先编写Subject接口，定义rent方法

```java
public interface Subject {
    public void rent();
}
```

接着编写一个房东类，房东需要去租房，是具体的逻辑实现

```java
public class LandLord implements Subject {
    @Override
    public void rent() {
        System.out.println("房东要租房");
    }
}
```

编写一个中介类，负责帮助房东租房

```java
public class Proxy implements Subject {
    public LandLord landLord;

    public Proxy(LandLord landLord){
        this.landLord = landLord;
    }

    @Override
    public void rent() {
        System.out.println("带你去看房");
        landLord.rent();
        System.out.println("带你签合同");
    }
}
```

最后就是真正的房客去租房了

```java
public class Demo {
    public static void main(String[] args) {
        LandLord landLord = new LandLord();
        Proxy proxy = new Proxy(landLord);
        proxy.rent();
    }
}
```

缺陷：程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，为这些目标类添加代理类，工作量太大了，因此增强目标类（比如打日志）变得很难处理。

## 动态代理

动态代理利用JDK API，动态的在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又称为JDK代理或接口代理。

**说到底就是生成的动态代理类可以代理所有的类**

静态代理和动态代理的区别：

* 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件
* 动态代理是在运行时动态生成，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中

以上面的租房为例，现在房东除了租房还要卖房

```java
public interface Subject {
    public void rent();
    public void sale();
}

public class LandLord implements Subject {
    @Override
    public void rent() {
        System.out.println("房东要租房");
    }

    @Override
    public void sale() {
        System.out.println("房东要卖房子");
    }
}
```

编写中介类ProxyHandler并测试

```java
public class Demo {
    public static void main(String[] args) {
        ProxyHandler proxyHandler=new ProxyHandler();
        Subject subject=(Subject) proxyHandler.newProxyInstance(new LandLord());
        subject.rent();
        System.out.println("==================");
        subject.sale();
    }
}


class ProxyHandler implements InvocationHandler {

    private Object targetObject;

    public Object newProxyInstance(Object targetObject){
        this.targetObject = targetObject;
        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("带你去看房");
        Object invoke = method.invoke(targetObject, args);
        System.out.println("带你去签合同");
        return invoke;
    }
}
```

## Java Proxy和cglib

使用java自带的API实现代理类，被代理的类必须实现接口；而cglib不需要这个要求