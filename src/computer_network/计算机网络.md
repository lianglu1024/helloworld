### 1.TCP/IP四层模型

![image.png](https://upload-images.jianshu.io/upload_images/6853111-a61d143d000103a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

OSI七层模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

### 2.一些概念

ip:标记逻辑上的地址 （决定了数据最终给谁）

Mac：标记实际转发数据时的设备地址 （决定了下一跳给谁，也就是说局域网内是靠MAC地址来传输数据）

子网掩码：和ip地址一起来确定网络号 

默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关 

TTL：初始值为128或其他，每经过一个路由器就减一，用于查看经过的路由器的个数 

### 3.tcp首部只有端口号没有ip地址，那么网络层怎么知道目的ip地址的呢？ 

1）就是说，应用层解析出ip地址后，把ip地址跨过传输层直接放到了网络层ip数据报的首部，所以传输层tcp首部就没有IP地址信息只有端口号了。 

2）确实，如果如书本上说的，每一层只管自己要的，dns解析的ip地址确实没法发到网络层，因为传输层tcp关注的头数据并不包括ip。但题主也知道，这样就没法工作了，所以实现上dns解析出ip地址后建立socket，然后进行connect系统调用的时候，ip地址实际上是作为参数传进去了，只不过tcp头封装的时候没放进去，而是放在ip头里面去了，这些东西书本上是讲标准，讲分层，但实现上可能就是程序。 

### 4.DHCP：Dynamic Host Configuration Protocol，动态主机配置协议 

DHCP服务器给客户主机动态分配ip地址。一般局域网内路由器就充当了DHCP服务器的功能 。

### 5.ARP 协议

ARP（Address Resolution Protocol），用于在局域网内，**将IP地址解析成Mac地址**。ARP协议只能在局域网内起作用，不能够跨网段 。在路由器与路由器之间，也要根据Mac地址将数据包下一跳给哪一个路由器，也就是说任何网络设备在进行数据转发的时候都要执行ARP协议（如果设备的ARP缓存中存在着对应ip的Mac，则不需要广播）

具体工作工程：

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系
2. 当主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址，以及目标MAC地址是FF-FF-FF-FF
3. 当本网络的所有主机收到ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略，如果是，则首先从数据包中取出源主机的IP的MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址
4. 源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败

 
### 6.ip地址的分类

每一个IP地址包括两部分：网络地址和主机地址

![image.png](https://upload-images.jianshu.io/upload_images/6853111-139e76385b4ac252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 私有ip

在这么多网络IP中，国际规定有一部分IP地址是用于我们的局域网使用，也就

是属于私网IP，不在公网中使用的，它们的范围是：

```
A类：10.0.0.0～10.255.255.255
B类：172.16.0.0～172.31.255.255
C类：192.168.0.0～192.168.255.255
```

### 7.ping的具体过程

ping执行的是网际控制报文协议 ICMP 

PING的工作流程 我们以下面一个网络为例：有 A、B、C、D 四台机子，一台路由 RA，子网掩码均为 255.255.255.0，默认路由为 192.168.0.1

1.在同一网段内 

在主机 A 上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping 命令会构建一个 固定格式的 ICMP 请求数据包， 然后由 ICMP 协议将这个数据包连同地址“192.168.0.5”一起 交给IP 层协议（和 ICMP 一样，实际上是一组后台运行的进程），IP 层协议将以地址 “192.168.0.5”作为目的地址，本机 IP 地址作为源地址，加上一些其他的控制信息，构建一 个 IP 数据包，并想办法得到 192.168.0.5 的MAC 地址（物理地址，这是数据链路层协议构 建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就 在这里，IP 层协议通过机器 B 的 IP 地址和自己的子网掩码，发现它跟自己属同一网络，就 直接在本网络内查找这台机器的 MAC,如果以前两机有过通信，在 A 机的 ARP 缓存表应该 有 B 机 IP 与其 MAC 的映射关系，如果没有，就发一个 ARP 请求广播，得到 B 机的 MAC, 一并交给数据链路层。后者构建一个数据帧，目的地址是 IP 层传过来的物理地址，源地址 则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送 出去。 主机 B 收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合， 则接收；否则丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层 协议。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议，后者处理后，马上构建 一个 ICMP 应答包，发送给主机 A，其过程和主机 A 发送 ICMP 请求包到主机 B 一模一样。 

2.不在同一网段内 

在主机 A 上运行“Ping 192.168.1.4”后，开始跟上面一样，到了怎样得到 MAC 地址时，IP 协议通过计算发现 D 机与自己不在同一网段内，就直接将交由路由处理，也就是将路由的 MAC 取过来，至于怎样得到路由的 MAC，跟上面一样，先在 ARP 缓存表找，找不到就广 播吧。路由得到这个数据帧后，再跟主机 D 进行联系，如果找不到，就向主机 A 返回一个 超时的信息。 


### 8.TCP和UDP的区别

TCP和UDP是OSI模型中的传输层的协议，TCP提供可靠的通信传输，而UDP则常用于让广播和细节控制交给应用的非可靠的通信传输

两者的区别大致如下：

* TCP面向连接，UDP面向非连接即发送数据前不需要建立连接
* TCP提供可靠的传输服务，UDP无法保证
* TCP数据传输慢，UDP数据传输快


### 9.请简要说一下你了解的端口及对应的服务

| 服务  | 端口 |
| ----- | ---- |
| http  | 80   |
| ssh   | 22   |
| mysql | 3306 |
| https | 443  |

### 10.TCP三次握手

![image.png](https://upload-images.jianshu.io/upload_images/6853111-74e96418a00f1980.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

第一次握手：客户端向服务端发送连接请求报文段，该报文段的头部中SYN=1，sequence number=x。请求发送后，客户端便进入SYN-SENT状态

第二次握手：服务端收到请求报文后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，sequence number=y，acknowledge number=x+1。该应答发送完成后便进入SYN-RCVD状态

第三次握手：当客户端收到连接同意的应答后，还要想服务端发送一个确认报文段，表示服务端发过来的连接同意应答已经成功收到。该报文的头部为：ACK=1，sequence number=x+1，acknowledge number=y+1。客户端发送完发完这个报文段后便进入ESTABLISHED状态，服务器收到这个应答报文也进入ESTABLISHED状态，此时连接的建立完成


### 11.TCP四次挥手

![image.png](https://upload-images.jianshu.io/upload_images/6853111-4d4014434505d74b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

以客户端主动关闭为例

第一次挥手：客户端向服务器发送连接释放请求。该请求只有报文头，头中携带的主要参数：FIN=1，sequence number=u。此时客户端进入FIN-WAIT-1状态

第二次挥手：服务器收到连接释放请求后，会通知相应的程序，告诉它客户端向服务端这个方向的连接已经释放。此时服务端进入CLOSE-WAIT状态，并向客户端发送连接释放的应答，其报文头包含：ACK=1，sequence number=v，acknowledge number=u+1。客户端收到该应答后，进入FIN-WAIT-2状态，等待服务端发送连接释放请求。第二次挥手完成后，客户端不会再接收数据，客户端也不会再发送数据。但服务端到客户端方向的连接仍然存在，服务端可以继续向客户端发送未完成的数据。

第三次挥手：当服务端向客户端发送完所有数据后，向客户端发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。服务端进入LAST-ACK状态。

第四次挥手：客户端收到释放请求后，向服务端发送确认应答，应答报文头：ACK=1，seq=u+1，ack=w+1，此时客户端进入TIME-WAIT状态。该状态会持续2MSL时间（报文最大生存时间），若该时间段内没有服务端的重发请求的话，就进入CLOSED状态。当服务端收到应答后，也便进入CLOSED状态。

为什么要等待2MSL时间后才进入CLOSED状态？

为了保证服务端能收到客户端的确认应答。如客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时就会重新发送连接释放请求，但此时客户端已经关闭了，不会做出任何响应，因此服务端无法正常关闭。

### 12.TCP的十种状态

Listen，SYN-SENT，SYN-RECV，ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，CLOSE-WAIT，TIME-WAIT，LAST-ACK，CLOSED

### 13.在浏览器输入网址之后执行会发生什么？

### 14.TCP的流量控制

[动画演示](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)

**TCP是利用滑动窗口实现流量控制。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。**

利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。

![image.png](https://upload-images.jianshu.io/upload_images/6853111-81769d66d5a82195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 （如果rwnd=1，就是停止等待协议，每发送一个确认一次），最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。

TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。

### 15.TCP拥塞控制

**拥塞控制就是防止过多的数据注入到网络中，这样使得网络中的路由器或者链路不至于过载。TCP拥塞控制方法主要包括：[慢开始，拥塞避免，快重传和快恢复](https://zhangbinalan.gitbooks.io/protocol/content/tcpde_yong_sai_kong_zhi.html)。**
   

### 16.TCP报文格式

![image.png](https://upload-images.jianshu.io/upload_images/6853111-d45f33189cb0ca6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600) 

固定首部长度为20字节,可变部分0~40字节,各字段解释：

1. 源端口，16bits，范围0~65525。
2. 目的端口，16bits，范围同上。
3. sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
4. acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。
5. 数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)（通过偏移量来确认TCP首部的长度，从而区分出哪些是TCP首部，哪些是数据部分）。
6. 保留字段6bits，保留今后使用，目前置0处理。
7. URG：紧急比特，1bit，当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) 
   ACK：确认比特，1bit，只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效
   PSH：推送比特，1bit，接收方TCP收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付
   RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接
   SYN：同步比特，1bit，同步比特SYN置为1，就表示这是一个连接请求或连接接受报文
   FIN：终止比特，1bit，用来释放一个连接。当FIN=1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接
8. 窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。
9. 检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP 报文段的前面加上12 字节的伪首部。
10. 紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。
11. 选项字段，长度可变。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）
    选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项
    kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍
    kind=2是最大报文段长度选项,TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。

# HTTP
## Http与Https的区别：

Http与Https的区别：

1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2. HTTP 是不安全的，而 HTTPS 是安全的
3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
6. HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

## 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。
也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。

## URI和URL的区别

URI和URL的区别

URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。

- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
- URI一般由三部组成：
- ①访问资源的命名机制
- ②存放资源的主机名
- ③资源自身的名称，由路径表示，着重强调于资源。

URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

- URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
- 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
- ①协议(或称为服务方式)
- ②存有该资源的主机IP地址(有时也包括端口号)
- ③主机资源的具体地址。如目录和文件名等

URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。

- URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

在Java的URI中，**一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。**

**在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。**

**相反的是，URL类可以打开一个到达资源的流。**

## 常用的HTTP方法有哪些？
* GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
* POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
* PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
* HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
* DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
* OPTIONS：查询相应URI支持的HTTP方法。

## HTTP请求报文与响应报文格式

请求报文包含四部分：

![img](https://segmentfault.com/img/remote/1460000013229039?w=735&h=272)

- a、请求行：包含请求方法、URI、HTTP版本信息
- b、请求首部字段
- c、请求内容实体
- d、空行

响应报文包含四部分：

![img](https://segmentfault.com/img/remote/1460000013229040?w=724&h=260)

- a、状态行：包含HTTP版本、状态码、状态码的原因短语
- b、响应首部字段
- c、响应内容实体
- d、空行

常见的首部：

- **通用首部字段（请求报文与响应报文都会使用的首部字段）**
  - Date：创建报文时间
  - Connection：连接的管理
  - Cache-Control：缓存的控制
  - Transfer-Encoding：报文主体的传输编码方式
- **请求首部字段（请求报文会使用的首部字段）**
  - Host：请求资源所在服务器
  - Accept：可处理的媒体类型
  - Accept-Charset：可接收的字符集
  - Accept-Encoding：可接受的内容编码
  - Accept-Language：可接受的自然语言
- **响应首部字段（响应报文会使用的首部字段）**
  - Accept-Ranges：可接受的字节范围
  - Location：令客户端重新定向到的URI
  - Server：HTTP服务器的安装信息
- **实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**
  - Allow：资源可支持的HTTP方法
  - Content-Type：实体主类的类型
  - Content-Encoding：实体主体适用的编码方式
  - Content-Language：实体主体的自然语言
  - Content-Length：实体主体的的字节数
  - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

## HTTPS工作原理

- 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 四、发送给服务端，此时只有服务端（RSA私钥）能解密。
- 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

![img](https://segmentfault.com/img/remote/1460000013271381?w=648&h=560)

具体的参考链接：<http://blog.csdn.net/sean_cd/article/details/6966130>

![image-20180709221503036](https://ws4.sinaimg.cn/large/006tKfTcgy1ft4hf64bn2j31kw0nxnku.jpg)

## 一次完整的HTTP请求所经历的7个步骤

[最具体的HTTP请求过程](http://blog.51cto.com/linux5588/1351007)

## 常见的HTTP相应状态码


* 200：请求被正常处理

* 204：请求被受理但没有资源可以返回

* 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
* 301：永久性重定向

* 302：临时重定向

* 303：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。URI上（**303和302状态码有着相同的功能**，但是303明确表示客户端应当采用get方法获取资源，这点与302状态码有区别）

* 304：发送附带条件的请求时，条件不满足时返回，与重定向无关

解释：当一个客户端（通常是浏览器）向web服务器发送一个请求，如果web服务器返回304响应，则表示此请求的**本地缓存是最新的**，可以直接使用。这种方法可以节省带宽，避免重复响应。
一般来说，可以将一个请求分为两类，二者以请求中包含的request header来区分：
有条件的请求（Conditional Validation Request）：If-Modified-Since 或者 If-None-Match	
无条件的请求（Unconditional Request）：None
一般来说If-Modified-Since的值来自于上一次这条请求的Response中的Last-Modified，If-None-Match的值来自于上一次这条请求的Response中的ETag。
如果是Conditional Request，则服务器去校验这两个header，并以此判断客户端的缓存是否是最新的，如果是，则返回一个HTTP/304 Not Modified header，其中response body为空；如果不是，则返回一个HTTP/200 OK header，并将最新的内容放在response body中。
所以如果需要很好的利用HTTP 304 Response，首先需要Web服务器，在其响应头中包含合理的值，例如Last-Modified和ETag，然后客户端才能据此发送Conditional Request。

* 307：临时重定向，与302类似，只是强制要求使用POST方法
* 400：请求报文语法有误，服务器无法识别
* 401：请求需要认证
* 404：服务器无法找到对应资源
* 500：服务器内部错误，一般指程序出现bug，抛出异常
* 503：服务器正忙，一般服务器出现宕机或者超过负载

## HTTP1.1版本新特性

- a、**默认持久连接节省通信量**，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
- b、**管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应**
- c、**断点续传**
  - **实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。**

## HTTP优化方案

我下面就简要概括一下：

- **TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。**
- **内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。**
- **压缩：将文本数据进行压缩，减少带宽**
- **SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速**
- **TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。**
