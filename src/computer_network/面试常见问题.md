## TCP首部

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghlv90shq0j30sd08hgn6.jpg)



- 16位源端口号和16位目的端口号。
- 32位序号：一次TCP通信过程中某一个传输方向上的字节流的某个字节的编号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
- 32位确认号：用来响应TCP报文段，给收到的TCP报文段的序号加1，三握时还要携带自己的序号。
- 4位头部长度：标识该TCP头部有多少个4字节，共表示最长15*4=60字节。同IP头部。
- 6位保留。6位标志。URG（紧急指针是否有效）ACK（表示确认号是否有效）PSH（提示接收端应用程序应该立即从TCP接收缓冲区读走数据）RST（表示要求对方重新建立连接）SYN（表示请求建立一个连接）FIN（表示通知对方本端要关闭连接）
- 16位窗口大小：TCP流量控制的一个手段，用来告诉对端TCP缓冲区还能容纳多少字节。
- 16位校验和：由发送端填充，接收端对报文段执行CRC算法以检验TCP报文段在传输中是否损坏。
- 16位紧急指针：一个正的偏移量，它和序号段的值相加表示最后一个紧急数据的下一字节的序号。



## 面向报文（UDP）和面向字节流（TCP）的区别

TCP 是一个可靠的、面向连接的、基于字节流、全双工的协议

**面向字节流怎么理解？**

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

## 粘包现象



## 三次握手和四次挥手

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmtpmf0urj30y50bq765.jpg)



![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmtqk7sv1j31c00r2n2o.jpg)

## 超时传输

**超时重传** TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定的时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间，如果还没有收到就再重传，在多次重传仍然失败以后，TCP 会放弃这个包。



## 滑动窗口之流量控制

TCP 包中`win=`表示接收窗口的大小，表示接收端还有多少缓冲区可以接收数据，当窗口变成 0 时，表示接收端不能暂时不能再接收数据了。 我们来看一个实际的例子，如下图所示

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmu3rg5o0j313j0u048n.jpg)

逐个解释一下

一开始三次握手确定接收窗口大小为 360 字节。

第一步：发送端发送 140 字节给接收端，此时因为 140 字节在途未确认，所以它的**可用滑动窗口大小**为：360 - 140 = 220

第二步：接收端收到 140 字节以后，将这 140 字节放入TCP 接收区缓冲队列。

正常情况下，接收端处理的速度非常快，这 140 字节会马上被应用层取走并释放这部分缓冲区，同时发送确认包给发送端，这样接收端的窗口大小（RCV.WND)马上可以恢复到 360 字节，发送端收到确认包以后也马上将可用发送滑动窗口恢复到 360 字节。

但是如果因为高负载等原因，导致 TCP 没有立马处理接收到的数据包，收到的 140 字节没能全部被取走，这个时候 TCP 会在返回的 ACK 里携带它建议的接收窗口大小，因为自己的处理能力有限，那就告诉对方下次发少一点数据嘛。假设如上图的场景，收到了 140 字节数据，现在只能从缓冲区队列取走 40 字节，还剩下 100 字节留在缓冲队列中，接收端将接收窗口从原来的 360 减小 100 变为 260。

第三步：发送端接收到 ACK 以后，根据接收端的指示，将自己的发送滑动窗口减小到 260。所有的数据都已经被确认，这时候可用窗口大小也等于 260

第四步：发送端继续发送 180 字节的数据给接收端，可用窗口= 260 - 180 = 80。

第五步：接收端收到 180 字节的数据，因为负载高等原因，没有能取走数据，将接收窗口再降低 180，变为 80，在回复给对端的 ACK 里携带回去。

第六步：发送端收到 ACK 以后，将自己的发送窗口减小到 80，同时可用窗口也变为 80

第七步：发送端继续发送 80 字节数据给接收端，在未确认之前在途字节数为 80，发送端可用窗口变为 0

第八步：接收端收到 80 字节的数据，放入接收区缓冲队列，但是入之前原因，没能取走，滑动窗口进一步减小到 0，在回复的 ACK 里捎带回去

第九步：发送端收到 ACK，根据发送端的指示，将自己的滑动窗口总大小减小为 0

##**拥塞控制** 



## TCP缓冲区





## MTU和MSS

最大传输单元（Maximum Transmission Unit， MTU）

TCP 最大段大小（Max Segment Size，MSS）

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmqdpalljj31b60eudjb.jpg)





## 补充

[TCP硬核面试题！35 张图解被问千百遍的 TCP 三次握手和四次挥手面试题](https://zhuanlan.zhihu.com/p/165497660)

