# 抽象类

类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类。类本身是不存在的，所以抽象类本身是无法创建对象。

**抽象类是无法实例化的**，无法创建对象的，所以抽象类是用来被继承的。

抽象类虽然不能实例化，但是有构造方法，这些构造方法是供子类使用

抽象类的子类可以是抽象类，也可以非抽象类

abstract和final不能连用，因为final是不可以被用来继承，而abstract是被用来继承的

![image-20200708155859793](https://tva1.sinaimg.cn/large/007S8ZIlly1ggjmest4e4j314k0kgtov.jpg)

抽象类的语法

```java
[修饰符列表] abstract class 类名{}
```

## 抽象方法

* 抽象方法就是**没有实现的方法**，并用abstract关键字修饰的方法
* 抽象类中可以有抽象方法，也可以没有抽象方法
* 有抽象方法的类必须是抽象类
* 一个非抽象的类继承抽象的类，需要将抽象类中所有抽象方法**全部实现**

```java
public class HelloWorld {
    public static void main(String[] args) {
        Animal bird = new Bird();
        bird.move();
    }
}

abstract class Animal{
    public abstract void move();

    public void eat(){}
}

/**
 * 非抽象类需要实现父类所有的抽象方法
 */
class  Bird extends Animal{
    @Override
    public void move(){
        System.out.println("x");
    }

}

/**
 * 抽象类可以实现父类的抽象方法，也可以不实现，不重写，不覆盖
 */
abstract class Cat extends Animal{

}
```

## 什么样的类需要定义成抽象类

？？？

# 接口

接口是完全抽象的，抽象类是半抽象的（里面可以定义非抽象方法）

定义一个接口：

```java
[修饰符列表] interface 接口名{
    全局常量;
    抽象方法;
}

interface ABC{
    public String name="abc";  // 等价于public static final String name="abc";
    public String find();  // 等价于public abstract String find();
}

/**
实现接口使用implements关键字
*/
class XYZ implements ABC{
    @Override
    public String find() {
        return null;
    }
}
```

接口的注意事项：

* 接口不能实例化对象，没有构造方法，相比于抽象类更抽象了
* 接口中只有常量和抽象方法
* 一个类继承了多个接口，那么就必须实现所有接口中的方法
* 接口不可以继承普通类和抽象类（貌似也没必要这么做）
* 接口中的所有元素都是public，目的就是为了继承的
* 接口中方法不能有方法体
* 使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）

### 解耦合的一般示例

公司里dubbo接口开发：

* 首先服务提供者写接口，然后打jar包。
* 消费者下载包并正常的开发代码，使用时用@Reference注解

例如：比如tms-center的某个方法想使用lis-center提供的范围查询接口，只需在类中加上

```java
@Reference
public CarrierServiceScopeFacade lisCarrierServiceScopeFacade;  
```

当容器启动的时候会自动执行

```java
CarrierServiceScopeFacade csf = new ProxyClass();
```

ProxyClass会复写CarrierServiceScopeFacade接口里的所有方法，而每个方法内部会通过网络请求到服务提供者的服务器上，服务提供者去执行自己的Impl方法。



## Java 中的接口有什么作用？

例如我定义了一个接口，但是我在继承这个接口的类中还要写接口的实现方法，那我不如直接就在这个类中写实现方法岂不是更便捷，还省去了定义接口？

https://www.zhihu.com/question/20111251

我总结了一下：

* 制定规范，让不同的实现者去实现。我知道 Comparable 这个接口是用来比较两个对象的，那么如何去比较呢？数字有数字的比较方法，字符串有字符串的比较方法，学生（自己定义的类）也有自己的比较方法。
* 如果只是让一个类去继承实现，而且以后也不太可能有其他类去继承实现，那么这个接口的意义并不大
* 接口就是一份契约，由类实现契约。契约中我编写了某些大的方针与前提，而签了约的类可以具体问题具体分析来实现自己的功能
* 在实际开发中，我们应用接口最多的就是多态特性，**就是俗称的面向抽象编程，面向接口编程**

摘自Java 中的接口有什么作用？ - 阿尔法汪的回答 - 知乎 https://www.zhihu.com/question/20111251/answer/173107739

> 作者：阿尔法汪
>
> 
>
> 就我目前的经验来看，接口于编程当中应用最多就是向上转型，毕竟实际操作处理实例为接口的实现子类。假设目前有接口IA，实现子类有BImpl，CImpl，使用以下方法即可实现向IA的向上转型： IA bImpl=new BImpl(); 或  CImpl cImpl=new CImpl(); IA cImpl=(IA)cImpl; 向上转型有什么用？可以从对外与对内来看。对外，即为外部调用者提供必须实现了所有接口方法的实例；对内，即将子例当中非接口方法强行屏蔽，只留下接口方法。 首先，从对外来说，当一个项目内部模块越来越多的时候，为保证管理的方便与可扩展，当然是尽量要求每个模块使用尽可能相同的标准。例如，某些软件要求其内部的业务模块全部实现生命周期接口，要求有init()、start()、stop()、restart()之类的方法实现，为的就是在可以方便操纵模块的生命周期状态转换。假设现在有一个模块List容器包含所有模块实例，要求启动所有的模块，可以使用如下的方法 for(Imodule module:list){ module.init(); module.start(); } 如果这些模块没有使用接口向上转型，而只是普通的不同类（当然它们可以都有init start之类的方法），但要实现以上的功能就得使用到反射了，而且还要声明抛出或处理没有该方法的异常。而想要新增一个新模块，只需要将新模块的业务类实现生命周期接口（也可以同时实现其他必要的接口）即可，扩展很方便。 
>
> 而对内来说，由于向上转型强行屏蔽了子类的其他方法，可以很好地起来权限控制与保障内部隐私的功能。 例如，有一级接口AImpl,接口方法有a1,a2…,二级接口BImpl实现了接口AImpl，同时新增本级接口方法有b1,b2…,以此类推.假设有有实例dImpl实现了四级接口DImpl,则此时dImpl对外接口除了d*系列之外，同时还有a*系列、b*系列和c*系列方法。如果dImpl实现了向三级接口CImpl的转型，则d*系列的方法将会被屏蔽，这就起到一个很好的方法权限访问的控制了。例如，可以设定dImpl对本模块内部暴露接口为四级接口，即可以被本模块其他类调用所有a,b,c,d系列方法；对相同业务模块暴露接口为三级接口，即只能被相同业务其他模块调用a,b,c系列方法；对本项目其他模块暴露二级接口，对其外项目暴露一级接口，调用关系如下 file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png 显然，只依赖private，protected，<default>，public这些访问控制关键字要做到上面的功能是比较复杂的，这个时候接口就很方便了。 至于保护隐私就像private方法一样，无法直接访问该方法，可以直到保护的作用。



# 抽象类和接口的区别

**接口是对动作的抽象，而抽象类是对对象的抽象**

* 抽象类

```java
[public] abstract class ClassName {
    abstract void fun();
}
```

1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public

2）抽象类不能用来创建对象

3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类

* 接口

```java
[public] interface InterfaceName {}
```

接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。

### 区别

抽象类是对一种事物的抽象，**即对类抽象，而接口是对行为的抽象**。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

抽象类和接口都不能被**直接**实例化，如果二者要实例化，就涉及到多态。如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象，这个子类继承了这个抽象类并实现了这个抽象类的所有抽象方法。如果接口要实例化，那么这个接口定义的变量要指向一个子类对象，这个子类必须实现了这个接口所有的方法